"""Simple, opinionated plotting helpers built on top of *load_results*.

This is **not** meant to recreate every figure generated by the historic
`plotData.py`.  Instead, it provides 80 % of the value for 10 % of the effort:
open the data and create high-level *summary* and *time-series* plots that are
reproducible in only a handful of lines.

Examples
--------
Summaries per scenario (peak flow):
>>> from plot_results import summary_by_duration
>>> summary_by_duration(r"e:/GitHub/URBS_BRCFScontroller/rsc", var="max_q")

Time-series of one duration / event / location:
>>> from plot_results import plot_timeseries
>>> plot_timeseries(r"e:/GitHub/URBS_BRCFScontroller/rsc", 
...                 scenario="DM_CC2", duration=3, event=0, location=5)
"""
from __future__ import annotations

from pathlib import Path
from typing import Literal

import matplotlib.pyplot as plt
import numpy as np

from load_results import ResultCollection

Duration = int  # alias – durations are stored as positional indices 0..10

# ---------------------------------------------------------------------------
# High-level convenience wrappers
# ---------------------------------------------------------------------------

def summary_by_duration(
    directory: str | Path,
    *,
    var: Literal["max_q", "max_h"] = "max_q",
    climate_split: bool = True,
    figsize=(10, 6),
    save: str | Path | None = None,
):
    """Bar-plot of the chosen **summary variable** against duration.

    Parameters
    ----------
    directory
        Folder that contains the result files (``DM_*.npz`` and
        ``DM_*ts.pkl``).
    var
        Which variable inside the ``.npz`` files to plot – either ``'max_q'``
        (peak flow) or ``'max_h'`` (peak water level).
    climate_split
        If *True* (default) the scenarios are grouped and coloured by *Existing*
        vs *Future Climate*.
    figsize
        Matplotlib figure size.
    save
        Optional path (PNG / PDF / SVG) where the figure should be written.
    """
        # Accept a `ResultCollection` passed directly, or build a new one from a path
    if isinstance(directory, ResultCollection):
        rc = directory
    else:
        rc = ResultCollection(directory)

    # Determine the number of durations from the first scenario.
    n_dur, *_ = next(iter(rc.values())).npz[var].shape
    durations = np.arange(n_dur)  # 0..N  – we do *not* convert to hours here

    fig, ax = plt.subplots(figsize=figsize)
    width = 0.8 / len(rc)  # make bars fit nicely side-by-side

    cmap = plt.cm.get_cmap("tab10")
    if climate_split:
        # Pre-compute an *order* so that Existing is left, Future right.
        scenarios = sorted(rc.scenarios, key=lambda s: ("CC" in s, s))
    else:
        scenarios = rc.scenarios

    for idx, scenario in enumerate(scenarios):
        data = rc[scenario].npz[var]  # shape: [duration, location]
        # We plot the *mean across locations* – can easily be changed to max/min.
        y = data.mean(axis=1)
        durations_local = np.arange(y.size)
        ax.bar(
            durations_local + idx * width,
            y,
            width=width,
            label=scenario,
            color=cmap(idx % 10),
            edgecolor="black",
            linewidth=0.3,
        )

    ax.set_xlabel("Duration index")
    ylabel = {"max_q": "Mean Peak Flow [m³/s]", "max_h": "Mean Peak WL [mAHD]"}[var]
    ax.set_ylabel(ylabel)
    ax.set_title(f"Summary of {var} by duration – grouped by scenario")
    ax.legend()
    ax.grid(axis="y", alpha=0.3)

    fig.tight_layout()
    if save:
        fig.savefig(save, dpi=300)
    return fig, ax


# ---------------------------------------------------------------------------


def plot_timeseries(
    directory: str | Path,
    *,
    scenario: str,
    duration: Duration,
    event: int,
    location: int,
    figsize=(10, 5),
    save: str | Path | None = None,
):
    """Plot **discharge** and **water level** time-series for a single run.

    ``duration`` / ``event`` / ``location`` follow the original indices from the
    Monte-Carlo simulations – *not* the physical units.  You can obtain valid
    ranges via::

        rc = ResultCollection(directory)
        ts = rc[scenario].timeseries  # dict – see below
        len(ts['qts'])        # number of durations
        ts['qts'][0].shape    # (events, locations, timesteps)
    """
        # Accept a `ResultCollection` passed directly, or build a new one from a path
    if isinstance(directory, ResultCollection):
        rc = directory
    else:
        rc = ResultCollection(directory)
    rf = rc[scenario]
    ts = rf.timeseries  # heavy – loaded once only

    qts = ts["qts"][duration][event, location, :]
    hts = ts["hts"][duration][event, location, :]
    n_steps = qts.size
    t = np.arange(n_steps)

    fig, ax_q = plt.subplots(figsize=figsize)
    ax_h = ax_q.twinx()

    ax_q.plot(t, qts, "b-", label="Q (flow)")
    ax_h.plot(t, hts, "r-", label="H (water level)")

    ax_q.set_xlabel("Timestep")
    ax_q.set_ylabel("Flow [m³/s]", color="b")
    ax_h.set_ylabel("Water level [m]", color="r")

    title = (
        f"Scenario {scenario} – Duration {duration} – Event {event} – Location {location}"
    )
    ax_q.set_title(title)

    # Combine legends from both y-axes.
    lines, labels = ax_q.get_legend_handles_labels()
    lines2, labels2 = ax_h.get_legend_handles_labels()
    ax_q.legend(lines + lines2, labels + labels2)

    fig.tight_layout()
    if save:
        fig.savefig(save, dpi=300)
    return fig, (ax_q, ax_h)
